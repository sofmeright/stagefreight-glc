spec:
  inputs:
    # input_section_name- GitLab Instance Config
    # input_section_desc- These are necessary for upload tasks etc
    gitlab_domain:
      description: "GitLab domain used to locate repository folders for uploads, etc."
    gitlab_token:
      description: 'Token for authenticating GitLab API calls.'
    # input_section_name- Gitlab Release Linking only work with Docker for now
    # input_section_desc- Configures embedding of the Docker Hub image into the release page
    docker_release_path:
      description: "Path/Name of the DockerHub Image to embed on the release page."
      default: ""
    # input_section_name- StageFreight Settings
    # input_section_desc- Core settings used by StageFreight
    freight_pipeline_status_file:
      description: 'Path to store "badge-release_status.svg" within parent pipelines repo.'
      default: "assets/badge-release_status.svg"
    # input_section_name- Security Scanning Settings
    # input_section_desc- Configure security scanning behavior
    security_scan_enabled:
      description: "Enable security vulnerability scanning with Trivy"
      type: boolean
      default: "true"
    security_fail_on_critical:
      description: "Fail the pipeline if critical vulnerabilities are found"
      type: boolean
      default: "false"
    security_sbom_enabled:
      description: "Generate Software Bill of Materials (SBOM)"
      type: boolean
      default: "true"
    # input_section_name- Docker Registry 1 Config
    # input_section_desc- Note that you can configure more than 3 by overriding
    freight_docker_url_1:
      description: "The registry endpoint to push the Docker image to (i.e. docker.io)"
      type: string
      default: ""
    freight_docker_user_1:
      description: "The username used to authenticate with the registry."
      type: string
      default: ""
    freight_docker_pass_1:
      description: "The password or access token for authentication."
      type: string
      default: ""
    freight_docker_path_1:
      description: "The full image path to push (i.e. prplanit/stagefreight)"
      type: string
      default: ""
    freight_docker_registry_1:
      description: "A friendly name used in logs to identify this registry."
      type: string
      default: ""
    # input_section_name- Docker Registry 2 Config
    # input_section_desc- Below this section are examples to configure more registries
    freight_docker_url_2:
      description: "The registry endpoint to push the Docker image to (i.e. docker.io)"
      type: string
      default: ""
    freight_docker_user_2:
      description: "The username used to authenticate with the registry."
      type: string
      default: ""
    freight_docker_pass_2:
      description: "The password or access token for authentication."
      type: string
      default: ""
    freight_docker_path_2:
      description: "The full image path to push (i.e. prplanit/stagefreight)"
      type: string
      default: ""
    freight_docker_registry_2:
      description: "A friendly name used in logs to identify this registry."
      type: string
      default: ""
    # input_section_name- Docker Registry 3 Config
    # input_section_desc- Below this section are examples to configure more registries
    freight_docker_url_3:
      description: "The registry endpoint to push the Docker image to (i.e. docker.io)"
      type: string
      default: ""
    freight_docker_user_3:
      description: "The username used to authenticate with the registry."
      type: string
      default: ""
    freight_docker_pass_3:
      description: "The password or access token for authentication."
      type: string
      default: ""
    freight_docker_path_3:
      description: "The full image path to push (i.e. prplanit/stagefreight)"
      type: string
      default: ""
    freight_docker_registry_3:
      description: "A friendly name used in logs to identify this registry."
      type: string
      default: ""

---

# Begin CI pipeline jobs
stages:
  - build
  - security  # New stage for security scanning
  - release

variables:
  BADGE_RELEASE_STATS_OUT: "$[[ inputs.freight_pipeline_status_file ]]"
  DOCKER_RELEASE_PATH: "$[[ inputs.docker_release_path ]]"
  GITLAB_DOMAIN: "$[[ inputs.gitlab_domain ]]"
  GITLAB_TOKEN: "$[[ inputs.gitlab_token ]]"
  SECURITY_SCAN_ENABLED: "$[[ inputs.security_scan_enabled ]]"
  SECURITY_FAIL_ON_CRITICAL: "$[[ inputs.security_fail_on_critical ]]"
  SECURITY_SBOM_ENABLED: "$[[ inputs.security_sbom_enabled ]]"

  DOCKER_HOST: "tcp://docker:2376"
  DOCKER_TLS_VERIFY: "1"
  DOCKER_CERT_PATH: "/certs/client"
  DOCKER_TLS_CERTDIR: "/certs"
  DOCKER_TAG: "$CI_COMMIT_TAG"
  GIT_TAG: "$CI_COMMIT_TAG"

  freight_docker_url_1: $[[ inputs.freight_docker_url_1 ]]
  freight_docker_user_1: $[[ inputs.freight_docker_user_1 ]]
  freight_docker_pass_1: $[[ inputs.freight_docker_pass_1 ]]
  freight_docker_path_1: $[[ inputs.freight_docker_path_1 ]]
  freight_docker_registry_1: $[[ inputs.freight_docker_registry_1 ]]

  freight_docker_url_2: $[[ inputs.freight_docker_url_2 ]]
  freight_docker_user_2: $[[ inputs.freight_docker_user_2 ]]
  freight_docker_pass_2: $[[ inputs.freight_docker_pass_2 ]]
  freight_docker_path_2: $[[ inputs.freight_docker_path_2 ]]
  freight_docker_registry_2: $[[ inputs.freight_docker_registry_2 ]]

  freight_docker_url_3: $[[ inputs.freight_docker_url_3 ]]
  freight_docker_user_3: $[[ inputs.freight_docker_user_3 ]]
  freight_docker_pass_3: $[[ inputs.freight_docker_pass_3 ]]
  freight_docker_path_3: $[[ inputs.freight_docker_path_3 ]]
  freight_docker_registry_3: $[[ inputs.freight_docker_registry_3 ]]

build-image:
  artifacts:
    reports:
      dotenv: release_hints_images.env
  image:
    name: docker.jcr.pcfae.com/prplanit/stagefreight:latest
    entrypoint: [""]
  needs: [export_dependencies]
  services:
    - name: docker.jcr.pcfae.com/docker:24.0.5-dind
      alias: docker
  stage: build
  before_script:
    - echo "Setting up Docker TLS context for buildx..."
    - docker context create tls-context --docker "host=$DOCKER_HOST,ca=$DOCKER_CERT_PATH/ca.pem,cert=$DOCKER_CERT_PATH/cert.pem,key=$DOCKER_CERT_PATH/key.pem"
    - docker buildx create --name stagefreight-builder --use tls-context
  script:
    - |
      set -euo pipefail
      ANY_PUSHED=false   # <— initialize so -u doesn't explode

      echo "Starting image build using buildx..."
      docker buildx build \
        --platform linux/amd64 \
        --tag "$CI_PROJECT_PATH:$CI_COMMIT_TAG" \
        --build-arg COMMIT_TAG="$CI_COMMIT_TAG" \
        --secret id=gitlab_token,env=CI_JOB_TOKEN \
        --output type=docker \
        -f Dockerfile .

      # Save the image for security scanning
      docker save -o image.tar "$CI_PROJECT_PATH:$CI_COMMIT_TAG"

      if [[ -n "${freight_docker_override:-}" ]]; then
        echo "Using overridden registry config."
        echo "$freight_docker_override" | yq -P '.' > /tmp/override_registry_list.yml
        count=$(yq '. | length' /tmp/override_registry_list.yml)

        for i in $(seq 0 $((count - 1))); do
          url=$(yq -r ".[$i].url" /tmp/override_registry_list.yml)
          user=$(yq -r ".[$i].user" /tmp/override_registry_list.yml)
          pass=$(yq -r ".[$i].pass" /tmp/override_registry_list.yml)
          path=$(yq -r ".[$i].path" /tmp/override_registry_list.yml)
          registry_name=$(yq -r ".[$i].registry // \"registry_${i}\"" /tmp/override_registry_list.yml)

          echo "Pushing to $registry_name ($url)..."
          echo "$pass" | docker login -u "$user" --password-stdin "$url"
          docker tag "$CI_PROJECT_PATH:$CI_COMMIT_TAG" "$url/$path:$CI_COMMIT_TAG"
          docker push "$url/$path:$CI_COMMIT_TAG" && ANY_PUSHED=true    # <—
          docker tag "$CI_PROJECT_PATH:$CI_COMMIT_TAG" "$url/$path:latest"
          docker push "$url/$path:latest" && ANY_PUSHED=true            # <—
        done
      else
        echo "Using up to 3 registry input slots..."
        for i in 1 2 3; do
          url_var="freight_docker_url_$i"
          user_var="freight_docker_user_$i"
          pass_var="freight_docker_pass_$i"
          path_var="freight_docker_path_$i"
          registry_var="freight_docker_registry_$i"

          url="${!url_var:-}"
          user="${!user_var:-}"
          pass="${!pass_var:-}"
          path="${!path_var:-}"
          registry="${!registry_var:-registry_$i}"

          if [[ -z "$url" || -z "$user" || -z "$pass" ]]; then
            echo "Skipping registry slot #$i: missing URL/user/pass"
            continue
          fi

          echo "Pushing to $registry ($url)..."
          echo "$pass" | docker login -u "$user" --password-stdin "$url"
          docker tag "$CI_PROJECT_PATH:$CI_COMMIT_TAG" "$url/$path:$CI_COMMIT_TAG"
          docker push "$url/$path:$CI_COMMIT_TAG" && ANY_PUSHED=true    # <—
          docker tag "$CI_PROJECT_PATH:$CI_COMMIT_TAG" "$url/$path:latest"
          docker push "$url/$path:latest" && ANY_PUSHED=true            # <—
        done
      fi

      # Emit a dotenv for downstream notes (always defined now)
      {
        echo "BUILT_IMAGES=${ANY_PUSHED}"
      } > release_hints_images.env
  artifacts:
    reports:
      dotenv: release_hints_images.env
    paths:
      - image.tar  # Save for security scanning
    expire_in: 1 hour
  rules:
    - if: '$CI_COMMIT_TAG'
      when: always

security-scan:
  stage: security
  image:
    name: docker.jcr.pcfae.com/prplanit/stagefreight:latest
    entrypoint: [""]
  services:
    - name: docker.jcr.pcfae.com/docker:24.0.5-dind
      alias: docker
  needs: ["build-image"]
  before_script:
    - |
      if [ "$SECURITY_SCAN_ENABLED" != "true" ]; then
        echo "Security scanning disabled. Skipping..."
        exit 0
      fi
    - apk add --no-cache curl jq bash wget tar
    - |
      # Install Trivy
      export TRIVY_VERSION=$(curl -s "https://api.github.com/repos/aquasecurity/trivy/releases/latest" | jq -r '.tag_name')
      wget -qO - https://github.com/aquasecurity/trivy/releases/download/${TRIVY_VERSION}/trivy_${TRIVY_VERSION#v}_Linux-64bit.tar.gz | tar -xz -C /usr/local/bin trivy
      chmod +x /usr/local/bin/trivy
    - |
      # Install Syft for SBOM if enabled
      if [ "$SECURITY_SBOM_ENABLED" = "true" ]; then
        curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
      fi
    - |
      # Install cosign for attestations
      COSIGN_VERSION="v2.2.2"
      curl -Lo /usr/local/bin/cosign https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign-linux-amd64
      chmod +x /usr/local/bin/cosign
    - |
      # Setup Docker context for buildx
      docker context create tls-context --docker "host=$DOCKER_HOST,ca=$DOCKER_CERT_PATH/ca.pem,cert=$DOCKER_CERT_PATH/cert.pem,key=$DOCKER_CERT_PATH/key.pem"
      docker buildx create --name attestation-builder --driver docker-container --use tls-context
    - |
      # Load the image
      docker load -i image.tar
  script:
    - |
      if [ "$SECURITY_SCAN_ENABLED" != "true" ]; then
        exit 0
      fi

      mkdir -p security-reports
      IMAGE_TAG="$CI_PROJECT_PATH:$CI_COMMIT_TAG"

      echo "🔍 Running security scan on: ${IMAGE_TAG}"

      # Run Trivy scan
      trivy image \
        --exit-code 0 \
        --format json \
        --output security-reports/trivy-report.json \
        ${IMAGE_TAG}

      # Generate table format for readability
      trivy image \
        --exit-code 0 \
        --format table \
        --output security-reports/trivy-report.txt \
        ${IMAGE_TAG}

      # Generate SARIF for GitLab integration
      trivy image \
        --exit-code 0 \
        --format sarif \
        --output security-reports/trivy-report.sarif \
        ${IMAGE_TAG}

      # Generate Trivy attestation format for Docker Hub
      trivy image \
        --exit-code 0 \
        --format cosign-vuln \
        --output security-reports/trivy-vuln.attestation.json \
        ${IMAGE_TAG}

      # Generate SBOM if enabled
      if [ "$SECURITY_SBOM_ENABLED" = "true" ]; then
        echo "📦 Generating Software Bill of Materials..."
        syft ${IMAGE_TAG} \
          --output spdx-json=security-reports/sbom.spdx.json \
          --output cyclonedx-json=security-reports/sbom.cyclonedx.json
      fi

      # Create security summary
      cat > security-reports/security-summary.md << EOF
      ## 🔒 Security Scan Results

      **Image:** \`${IMAGE_TAG}\`
      **Scan Date:** $(date -u +%Y-%m-%dT%H:%M:%SZ)

      ### Vulnerability Summary
      EOF

      CRITICAL=$(jq '[.Results[].Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' security-reports/trivy-report.json || echo "0")
      HIGH=$(jq '[.Results[].Vulnerabilities[]? | select(.Severity=="HIGH")] | length' security-reports/trivy-report.json || echo "0")
      MEDIUM=$(jq '[.Results[].Vulnerabilities[]? | select(.Severity=="MEDIUM")] | length' security-reports/trivy-report.json || echo "0")
      LOW=$(jq '[.Results[].Vulnerabilities[]? | select(.Severity=="LOW")] | length' security-reports/trivy-report.json || echo "0")

      echo "- **🔴 Critical:** ${CRITICAL}" >> security-reports/security-summary.md
      echo "- **🟠 High:** ${HIGH}" >> security-reports/security-summary.md
      echo "- **🟡 Medium:** ${MEDIUM}" >> security-reports/security-summary.md
      echo "- **🟢 Low:** ${LOW}" >> security-reports/security-summary.md

      # Create security badge info
      if [ "$CRITICAL" -gt 0 ]; then
        BADGE_COLOR="red"
        BADGE_STATUS="critical"
      elif [ "$HIGH" -gt 0 ]; then
        BADGE_COLOR="orange"
        BADGE_STATUS="high"
      else
        BADGE_COLOR="green"
        BADGE_STATUS="passing"
      fi

      echo "SECURITY_BADGE_URL=https://img.shields.io/badge/security-${BADGE_STATUS}-${BADGE_COLOR}" > security-reports/badge.env

      # ======================================================================
      # Push attestations to Docker Hub (and other registries that support it)
      # ======================================================================
      echo "📎 Pushing security attestations to registries..."

      # Function to detect registry vendor (same logic as release links)
      detect_registry_vendor() {
        local url="$1"
        local reg_name="$2"

        local host="${url#*://}"; host="${host%%/*}"
        local lhost="$(echo "$host" | tr '[:upper:]' '[:lower:]')"
        local lname="$(echo "$reg_name" | tr '[:upper:]' '[:lower:]')"

        if [[ "$lhost" == *"docker.io"* || "$url" == "docker.io" || "$lname" == *"dockerhub"* || "$lname" == *"docker hub"* || "$lname" == "docker" ]]; then
          echo "dockerhub"
        elif [[ "$lhost" == *"ghcr.io"* || "$lname" == *"ghcr"* ]]; then
          echo "ghcr"
        elif [[ "$lhost" == *"quay"* || "$lname" == *"quay"* ]]; then
          echo "quay"
        else
          echo "other"
        fi
      }

      # Function to push attestations to Docker Hub
      push_dockerhub_attestations() {
        local image_url="$1"
        local user="$2"
        local pass="$3"

        echo "🐳 Pushing attestations to Docker Hub: ${image_url}"

        # Login to Docker Hub
        echo "$pass" | docker login -u "$user" --password-stdin docker.io

        # Create SBOM attestation if available
        if [ -f security-reports/sbom.spdx.json ]; then
          echo "  📦 Attaching SBOM attestation..."

          # Create attestation using buildx (Docker Hub native support)
          docker buildx imagetools create \
            --tag "${image_url}:${CI_COMMIT_TAG}" \
            --annotation "vnd.docker.reference.type=attestation" \
            --annotation "vnd.docker.reference.digest=sbom" \
            --file security-reports/sbom.spdx.json \
            "${image_url}:${CI_COMMIT_TAG}" 2>/dev/null || {
              # Fallback: Use cosign if buildx fails
              echo "    Using cosign for SBOM attestation..."
              cosign attest --yes \
                --predicate security-reports/sbom.spdx.json \
                --type spdxjson \
                "${image_url}:${CI_COMMIT_TAG}" 2>/dev/null || echo "    ⚠️ Failed to attach SBOM"
            }
        fi

        # Create vulnerability attestation
        if [ -f security-reports/trivy-vuln.attestation.json ]; then
          echo "  🔍 Attaching vulnerability attestation..."

          # Create custom attestation for vulnerabilities
          cat > vuln-attestation.json << ATTESTATION_EOF
      {
        "_type": "https://in-toto.io/Statement/v0.1",
        "predicateType": "https://cosign.dev/attestation/vuln/v1",
        "subject": [
          {
            "name": "${image_url}",
            "digest": {
              "sha256": "$(docker inspect --format='{{index .RepoDigests 0}}' ${image_url}:${CI_COMMIT_TAG} | cut -d@ -f2 | cut -d: -f2)"
            }
          }
        ],
        "predicate": {
          "scanner": {
            "uri": "pkg:github/aquasecurity/trivy",
            "version": "latest",
            "db": {
              "uri": "pkg:github/aquasecurity/trivy-db",
              "version": "latest"
            }
          },
          "metadata": {
            "scanStartedOn": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "scanFinishedOn": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "repoUri": "$CI_PROJECT_URL",
            "commit": "$CI_COMMIT_SHA"
          },
          "result": {
            "criticalCount": ${CRITICAL},
            "highCount": ${HIGH},
            "mediumCount": ${MEDIUM},
            "lowCount": ${LOW},
            "unknownCount": 0
          }
        }
      }
      ATTESTATION_EOF

          cosign attest --yes \
            --predicate vuln-attestation.json \
            --type vuln \
            "${image_url}:${CI_COMMIT_TAG}" 2>/dev/null || echo "    ⚠️ Failed to attach vulnerability attestation"
        fi

        # Update Docker Hub description via API (if possible)
        echo "  📝 Updating Docker Hub description..."

        # Extract namespace and repo name
        local namespace="${image_url%/*}"
        namespace="${namespace#*/}"  # Remove docker.io/ if present
        local repo="${image_url##*/}"
        
        # Create description with security info
        cat > dockerhub-description.md << DESC_EOF
      ## Security Information
      
      This image is automatically scanned for vulnerabilities.
      
      ### Latest Scan Results (${CI_COMMIT_TAG})
      
      - 🔴 Critical: ${CRITICAL}
      - 🟠 High: ${HIGH}
      - 🟡 Medium: ${MEDIUM}
      - 🟢 Low: ${LOW}
      
      ### Retrieving Attestations
      
      To view the Software Bill of Materials:
      \`\`\`bash
      docker buildx imagetools inspect ${image_url}:${CI_COMMIT_TAG} --format "{{json .SBOM}}"
      \`\`\`
      
      To verify attestations with cosign:
      \`\`\`bash
      cosign verify-attestation ${image_url}:${CI_COMMIT_TAG}
      \`\`\`
      
      Last scan: $(date -u +%Y-%m-%dT%H:%M:%SZ)
      DESC_EOF
        
        # Note: Docker Hub API for updating descriptions requires JWT token
        # This would need additional setup, so we just prepare the file
        echo "    ℹ️ Docker Hub description prepared in dockerhub-description.md"
      }

      # Process each registry
      if [[ -n "${freight_docker_override:-}" ]]; then
        echo "Processing overridden registry list..."
        echo "$freight_docker_override" | yq -P '.' > /tmp/override_registry_list.yml
        count=$(yq '. | length' /tmp/override_registry_list.yml)

        for i in $(seq 0 $((count - 1))); do
          url=$(yq -r ".[$i].url" /tmp/override_registry_list.yml)
          user=$(yq -r ".[$i].user" /tmp/override_registry_list.yml)
          pass=$(yq -r ".[$i].pass" /tmp/override_registry_list.yml)
          path=$(yq -r ".[$i].path" /tmp/override_registry_list.yml)
          registry_name=$(yq -r ".[$i].registry // \"registry_${i}\"" /tmp/override_registry_list.yml)

          [[ -z "$url" || -z "$user" || -z "$pass" || -z "$path" ]] && continue

          vendor=$(detect_registry_vendor "$url" "$registry_name")

          if [ "$vendor" = "dockerhub" ]; then
            # For Docker Hub, use special attestation flow
            push_dockerhub_attestations "docker.io/$path" "$user" "$pass"
          else
            echo "ℹ️ Skipping attestations for $registry_name (vendor: $vendor) - not Docker Hub"
          fi
        done
      else
        echo "Processing standard registry slots..."
        for i in 1 2 3; do
          url_var="freight_docker_url_$i"
          user_var="freight_docker_user_$i"
          pass_var="freight_docker_pass_$i"
          path_var="freight_docker_path_$i"
          registry_var="freight_docker_registry_$i"

          url="${!url_var:-}"
          user="${!user_var:-}"
          pass="${!pass_var:-}"
          path="${!path_var:-}"
          registry="${!registry_var:-registry_$i}"

          [[ -z "$url" || -z "$user" || -z "$pass" || -z "$path" ]] && continue

          vendor=$(detect_registry_vendor "$url" "$registry")

          if [ "$vendor" = "dockerhub" ]; then
            # Ensure we use docker.io as the URL for Docker Hub
            if [[ "$url" == "docker.io" || "$url" == "https://docker.io" || "$url" == "http://docker.io" ]]; then
              push_dockerhub_attestations "docker.io/$path" "$user" "$pass"
            else
              echo "ℹ️ Registry $registry detected as Docker Hub but URL is $url - skipping attestations"
            fi
          else
            echo "ℹ️ Skipping attestations for $registry (vendor: $vendor) - not Docker Hub"
          fi
        done
      fi

      # Optionally fail on critical vulnerabilities
      if [ "$SECURITY_FAIL_ON_CRITICAL" = "true" ] && [ "$CRITICAL" -gt 0 ]; then
        echo "❌ Critical vulnerabilities found! Failing pipeline."
        trivy image --exit-code 1 --severity CRITICAL ${IMAGE_TAG}
      fi
  artifacts:
    reports:
      container_scanning: security-reports/trivy-report.sarif
    paths:
      - security-reports/
      - dockerhub-description.md
      - vuln-attestation.json
    expire_in: 30 days
  allow_failure: true
  rules:
    - if: '$CI_COMMIT_TAG && $SECURITY_SCAN_ENABLED == "true"'
      when: always
    - when: never

# Enhanced generate_release_notes with security info
generate_release_notes:
  stage: release
  image: docker.jcr.pcfae.com/prplanit/stagefreight:latest
  needs:
    - export_dependencies
    - build-image
    - job: security-scan
      optional: true  # Make it optional so it doesn't fail if security scan is disabled
  only: [tags]
  artifacts:
    paths:
      - release.md
      - assets/
      - scripts/
    expire_in: 1 hour
  before_script:
    - apk add --no-cache bash curl git
    - echo "Listing files for debugging"
    - find . -type f
    - cat ./scripts/gitlab/generate-release_notes.sh
    - chmod +x scripts/gitlab/generate-release_notes.sh
  script:
    - scripts/gitlab/generate-release_notes.sh > release_base.md
    - |
      # Add security information if available
      if [ -f security-reports/security-summary.md ]; then
        cat release_base.md > release.md
        echo "" >> release.md
        cat security-reports/security-summary.md >> release.md
        
        if [ "$SECURITY_SBOM_ENABLED" = "true" ]; then
          echo "" >> release.md
          echo "### 📋 Software Bill of Materials" >> release.md
          echo "SBOM files are available as release assets in SPDX and CycloneDX formats." >> release.md
        fi
        
        # Add security badge
        if [ -f security-reports/badge.env ]; then
          source security-reports/badge.env
          echo "" >> release.md
          echo "![Security Status](${SECURITY_BADGE_URL})" >> release.md
        fi
      else
        cp release_base.md release.md
      fi
    - test -s release.md || (echo "❌ release.md is empty!" && exit 1)

create-release:
  stage: release
  image: docker.jcr.pcfae.com/prplanit/stagefreight:latest
  only: [tags]
  needs: [generate_release_notes]
  before_script:
    - apk add --no-cache bash curl jq
  script:
    - RELEASE_NOTES=$(cat release.md)
    - |
      curl --silent --fail --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
        --request POST \
        --form "name=Release $CI_COMMIT_TAG" \
        --form "tag_name=$CI_COMMIT_TAG" \
        --form "description=$RELEASE_NOTES" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/releases" || echo "Release might already exist"
    - |
      # --- Dynamic Release Links ---------------------------------------------------
      set -euo pipefail

      # Helpers
      json_escape() { jq -Rn --arg s "$1" '$s'; }

      build_registry_link() {
        local url="$1" path="$2" tag="$3" reg_name="$4"

        # host parts
        local host="${url#*://}"; host="${host%%/*}"
        local first_label="${host%%.*}"

        # normalize to lowercase for detection
        local lhost="$(echo "$host" | tr '[:upper:]' '[:lower:]')"
        local lname="$(echo "$reg_name" | tr '[:upper:]' '[:lower:]')"

        # vendor guess
        local vendor=""
        if [[ "$lhost" == *"docker.io"* || "$lname" == *"dockerhub"* || "$lname" == *"docker hub"* ]]; then vendor="dockerhub"; fi
        if [[ "$lhost" == *"ghcr.io"* || "$lname" == *"ghcr"* ]]; then vendor="ghcr"; fi
        if [[ "$lhost" == *"quay"* || "$lname" == *"quay"* ]]; then vendor="quay"; fi
        if [[ "$lhost" == *"jfrog"* || "$lhost" == *"artifactory"* || "$lname" == *"jfrog"* || "$lname" == *"jcr"* ]]; then vendor="jfrog"; fi
        # self-managed GitLab registry (e.g., registry.gitlab.example.com) or registry on same domain
        if [[ -n "${GITLAB_DOMAIN:-}" ]]; then
          local lgit="$(echo "$GITLAB_DOMAIN" | tr '[:upper:]' '[:lower:]')"
          if [[ "$lhost" == *"gitlab"* || "$lhost" == *"$lgit"* ]]; then vendor="gitlab"; fi
        fi

        # build link
        local link=""
        case "$vendor" in
          dockerhub)
            link="https://hub.docker.com/r/${path}/tags?page=1&name=${tag}"
            ;;
          ghcr)
            # path "owner/image"
            local owner="${path%%/*}"
            local image="${path#*/}"
            # assume org package page (works for orgs; for users the path is /users/<owner>/...)
            link="https://github.com/orgs/${owner}/packages/container/package/${image}"
            ;;
          quay)
            # Quay-like UI (your example: https://cr.pcfae.com/repository/<ns>/<repo>)
            link="https://${host}/repository/${path}"
            ;;
          jfrog)
            # Artifactory UI (your example): https://<host>/ui/repos/tree/General/<repoKey>/<ns>/<repo>
            # use first subdomain as repoKey (e.g., 'docker' in docker.jcr.pcfae.com), fallback to 'docker'
            local repokey="${first_label:-docker}"
            link="https://${host}/ui/repos/tree/General/${repokey}/${path}"
            ;;
          gitlab)
            # Try to form GitLab Packages (Container) page:
            #   https://<gitlab-domain>/<group>/<project>/-/packages/container[/<image>]
            IFS='/' read -ra parts <<< "$path"
            if (( ${#parts[@]} >= 2 )); then
              local group="${parts[0]}"
              local project="${parts[1]}"
              if (( ${#parts[@]} > 2 )); then
                local image_path="${path#${group}/${project}/}"
                link="https://${GITLAB_DOMAIN}/${group}/${project}/-/packages/container/${image_path}"
              else
                link="https://${GITLAB_DOMAIN}/${group}/${project}/-/packages/container"
              fi
            else
              link="https://${GITLAB_DOMAIN}/-/packages"
            fi
            ;;
          *)
            # Generic OCI v2 manifest endpoint (not pretty UI but always exists)
            link="${url}/v2/${path}/manifests/${tag}"
            ;;
        esac

        echo "$link"
      }

      post_link_if_missing() {
        local name="$1" url="$2" type="$3"
        # Skip if already present (name or URL)
        if echo "$EXISTING_LINKS_JSON" | jq -e --arg n "$name" --arg u "$url" '.[] | select(.name==$n or .url==$u)' >/dev/null; then
          echo "Link exists: $name — skipping"
          return 0
        fi
        echo "Embedding release link: $name -> $url"
        curl --silent --fail \
          --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
          --header "Content-Type: application/json" \
          --data "{\"name\":$(json_escape "$name"),\"url\":$(json_escape "$url"),\"link_type\":\"$type\"}" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/releases/$CI_COMMIT_TAG/assets/links" \
          || echo "⚠️ Failed to add link: $name"
      }

      # Pull existing links once for idempotency
      EXISTING_LINKS_JSON="$(curl --silent --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/releases/$CI_COMMIT_TAG/assets/links" || echo "[]")"

      # 1) Links for override list (freight_docker_override via yq)
      if [[ -n "${freight_docker_override:-}" ]]; then
        echo "$freight_docker_override" | yq -P '.' > /tmp/override_registry_list.yml
        count=$(yq '. | length' /tmp/override_registry_list.yml)
        for i in $(seq 0 $((count - 1))); do
          url=$(yq -r ".[$i].url" /tmp/override_registry_list.yml)
          path=$(yq -r ".[$i].path" /tmp/override_registry_list.yml)
          reg_name=$(yq -r ".[$i].registry // \"registry_${i}\"" /tmp/override_registry_list.yml)

          [[ -z "$url" || -z "$path" ]] && { echo "Skip override[$i]: missing url/path"; continue; }

          link="$(build_registry_link "$url" "$path" "$CI_COMMIT_TAG" "$reg_name")"
          post_link_if_missing "${reg_name} ${CI_COMMIT_TAG}" "$link" "image"
        done
      else
        # 2) Links for the three input slots
        for i in 1 2 3; do
          url_var="freight_docker_url_$i"
          path_var="freight_docker_path_$i"
          name_var="freight_docker_registry_$i"

          url="${!url_var:-}"
          path="${!path_var:-}"
          reg_name="${!name_var:-registry_$i}"

          [[ -z "$url" || -z "$path" ]] && { echo "Skip slot #$i: missing url/path"; continue; }

          link="$(build_registry_link "$url" "$path" "$CI_COMMIT_TAG" "$reg_name")"
          post_link_if_missing "${reg_name} ${CI_COMMIT_TAG}" "$link" "image"
        done
      fi

      # 3) Add security report links if available
      if [ -f security-reports/sbom.spdx.json ]; then
        post_link_if_missing "SBOM (SPDX)" "$CI_PROJECT_URL/-/jobs/artifacts/$CI_COMMIT_TAG/raw/security-reports/sbom.spdx.json?job=security-scan" "other"
      fi
      if [ -f security-reports/sbom.cyclonedx.json ]; then
        post_link_if_missing "SBOM (CycloneDX)" "$CI_PROJECT_URL/-/jobs/artifacts/$CI_COMMIT_TAG/raw/security-reports/sbom.cyclonedx.json?job=security-scan" "other"
      fi
      if [ -f security-reports/trivy-report.json ]; then
        post_link_if_missing "Security Scan Report" "$CI_PROJECT_URL/-/jobs/artifacts/$CI_COMMIT_TAG/raw/security-reports/trivy-report.json?job=security-scan" "other"
      fi
      # ---------------------------------------------------------------------------

update-release-badge:
  artifacts:
    paths:
      - release.md
      - assets/badge-release-generic.svg
      - scripts/
  stage: release
  image: docker.jcr.pcfae.com/prplanit/stagefreight:latest
  only: [tags]
  needs: [create-release, generate_release_notes]
  script: |
    set -e
    apk add --no-cache curl jq bash coreutils
    JOB_STATUSES=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_TOKEN" "$CI_API_V4_URL/projects/$CI_PROJECT_ID/pipelines/$CI_PIPELINE_ID/jobs" | jq -r '.[].status')
    ALL_SUCCESS=true
    ANY_FAILED=false
    for status in $JOB_STATUSES; do
      case "$status" in
        failed) ANY_FAILED=true; ALL_SUCCESS=false;;
        running|pending) ALL_SUCCESS=false;;
      esac
    done
    if [ "$ALL_SUCCESS" = true ]; then
      STATUS="passed"; COLOR="#4c1"
    elif [ "$ANY_FAILED" = true ]; then
      STATUS="failed"; COLOR="#e05d44"
    else
      STATUS="running"; COLOR="#dfb317"
    fi
    sed -e "s|{{COLOR}}|$COLOR|g" -e "s|{{STATUS}}|$STATUS|g" "assets/badge-release-generic.svg" > "$BADGE_RELEASE_STATS_OUT"
    CONTENT_BASE64=$(base64 -w 0 "$BADGE_RELEASE_STATS_OUT")
    ENCODED_FILE_PATH=$(echo "$BADGE_RELEASE_STATS_OUT" | sed 's/\//%2F/g')
    curl --request PUT --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
      --header "Content-Type: application/json" \
      --data "{
        \"branch\": \"main\",
        \"content\": \"$CONTENT_BASE64\",
        \"commit_message\": \"Update release badge for $CI_COMMIT_TAG\",
        \"encoding\": \"base64\"
      }" \
      "$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/files/$ENCODED_FILE_PATH"