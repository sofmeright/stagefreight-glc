spec:
  inputs:
    # input_section_name- StageFreight Settings
    # input_section_desc- Core settings used by StageFreight.
    badge_template:
      default: "assets/badge-release-generic.svg"
      description: "SVG template for badge generation"
    badge_output:
      default: "assets/badge-release-status.svg"
      description: "Final badge output path"
    component_spec_files:
      description: "Array of component spec files (for README input info)"
      type: array
    readme_file:
      default: "README.md"
      description: "README file to inject Markdown input map into"
    # input_section_name- GitLab CI/CD Inputs
    # input_section_desc- Inputs that configure GitLab Job behavior
    gitlab_branch:
      default: 'main'
      description: 'Target Git branch for commits.'
    gitlab_domain:
      default: "https://gitlab.prplanit.com"
      description: "Base GitLab domain (used for badge & catalog links)"
    gitlab_token:
      description: 'Token for authenticating GitLab API calls.'

---

# Begin CI pipeline jobs
stages:
  - build
  - release

variables:
  GITLAB_BRANCH: $[[ inputs.gitlab_branch ]]
  GITLAB_DOMAIN: $[[ inputs.gitlab_domain ]]
  GITLAB_TOKEN: $[[ inputs.gitlab_token ]]
  README_FILE: $[[ inputs.readme_file ]]

generate_readme_component_inputs:
  artifacts:
    paths:
      - artifacts/
      - assets/
      - scripts/
      - templates/
      - README.md
      - release.md
      - $[[ inputs.badge_output ]]
    expire_in: 1 hour
  stage: release
  image: docker.jcr.pcfae.com/prplanit/stagefreight:latest
  rules:
    - if: '$CI_COMMIT_TAG'
  variables:
    YQ_VERSION: "v4.44.1"
    YQ_BINARY: "yq_linux_amd64"
  before_script:
    - apk add --no-cache bash coreutils curl jq tree
    - curl -Ls "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/${YQ_BINARY}" -o /usr/bin/yq
    - chmod +x /usr/bin/yq
  script:
    - echo "Releasing from branch- $CI_COMMIT_REF_NAME"
    - echo "Pipeline ID- $CI_PIPELINE_ID"
    - echo "API URL- $CI_API_V4_URL"
    - echo "Project ID- $CI_PROJECT_ID"
    - echo "Current tag- $CI_COMMIT_TAG"

    - mkdir -p artifacts

    - chmod +x scripts/gitlab/components/generate-component_inputs_batch.sh
    - chmod +x scripts/gitlab/components/generate-component_inputs_table.sh
    - ./scripts/gitlab/components/generate-component_inputs_batch.sh "$[[ inputs.component_spec_files ]]" artifacts/component_inputs.md

    - echo "--- Generated Markdown ---"
    - cat artifacts/component_inputs.md
    - echo "--- End of Markdown ---"

    # Inject into README between custom tags
    - |
      START_TAG="<!-- START_C_INPUTS_MAP -->"
      END_TAG="<!-- END_C_INPUTS_MAP -->"

      awk -v start="$START_TAG" -v end="$END_TAG" -v file="artifacts/component_inputs.md" '
        BEGIN {
          inblock = 0
          while ((getline line < file) > 0) {
            lines[++n] = line
          }
          close(file)
        }
        {
          if ($0 ~ start) {
            print
            for (i = 1; i <= n; i++) print lines[i]
            inblock = 1
            next
          }
          if ($0 ~ end) {
            inblock = 0
          }
          if (!inblock) print
        }
      ' "$README_FILE" > updated_readme.md

    # Upload the updated README
    - |
      CONTENT_BASE64=$(base64 -w 0 updated_readme.md)
      ENCODED_FILE_PATH=$(printf '%s' "$README_FILE" | jq -s -R -r @uri)
      curl --request PUT --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
          --header "Content-Type: application/json" \
          --data "{
            \"branch\": \"$GITLAB_BRANCH\",
            \"content\": \"$CONTENT_BASE64\",
            \"commit_message\": \"Update component input map for $CI_COMMIT_TAG\",
            \"encoding\": \"base64\"
          }" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/files/$ENCODED_FILE_PATH"

generate_release_notes:
  stage: release
  image: docker.jcr.pcfae.com/prplanit/stagefreight:latest
  only: [tags]
  artifacts:
    paths: 
      - release.md
      - assets/
      - scripts/
    expire_in: 1 hour
  before_script: |
    apk add --no-cache bash curl git tree
  script:
    - |
      echo "Listing files for debugging:"
      tree scripts
      echo "Content of generate-release_notes.sh:"
      cat ./scripts/gitlab/generate-release_notes.sh

      echo "Fetching tags history to provide info about changes..."
      git fetch --tags

      echo "Making generate-release_notes.sh executable..."
      chmod +x ./scripts/gitlab/generate-release_notes.sh
      echo "Execute generate-release_notes.sh and output to release.md..."
      ./scripts/gitlab/generate-release_notes.sh > release.md
      test -s release.md || (echo "❌ release.md is empty!" && exit 1)

create-release:
  stage: release
  image: docker.jcr.pcfae.com/prplanit/stagefreight:latest
  only: [tags]
  needs: [generate_release_notes]
  before_script:
    - apk add --no-cache bash curl jq
  script:
    - RELEASE_NOTES=$(cat release.md)
    - >
      curl --fail --silent --header "PRIVATE-TOKEN: $GITLAB_TOKEN" --request POST
      --form "name=Release $CI_COMMIT_TAG"
      --form "tag_name=$CI_COMMIT_TAG"
      --form "description=$RELEASE_NOTES"
      "$CI_API_V4_URL/projects/$CI_PROJECT_ID/releases" || echo "Release might already exist"
    - COMPONENT_NAME="$CI_PROJECT_NAME"
    - CATALOG_LINK="$GITLAB_DOMAIN/explore/catalog/components/$COMPONENT_NAME"
    - >
      curl --silent --fail --header "PRIVATE-TOKEN: $GITLAB_TOKEN"
      --request POST --header "Content-Type: application/json"
      --data "{\"name\":\"$CI_PROJECT_NAME:$CI_COMMIT_TAG Component in GitLab Catalog\",\"url\":\"$CATALOG_LINK\",\"link_type\":\"other\"}"
      "$CI_API_V4_URL/projects/$CI_PROJECT_ID/releases/$CI_COMMIT_TAG/assets/links"

update_release_pipeline_status_badge:
  artifacts:
    paths: 
      - release.md
      - assets/badge-release-generic.svg
      - scripts/
  stage: release
  image: docker.jcr.pcfae.com/prplanit/stagefreight:latest
  only: [tags]
  needs: [create-release, generate_release_notes]
  script: |
    apk add --no-cache curl jq bash coreutils
    JOB_STATUSES=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_TOKEN" "$CI_API_V4_URL/projects/$CI_PROJECT_ID/pipelines/$CI_PIPELINE_ID/jobs" | jq -r '.[].status')

    ALL_SUCCESS=true
    ANY_FAILED=false
    for status in $JOB_STATUSES; do
      case "$status" in
        failed) ANY_FAILED=true; ALL_SUCCESS=false;;
        running|pending) ALL_SUCCESS=false;;
      esac
    done

    if [ "$ALL_SUCCESS" = true ]; then
      STATUS="passed"; COLOR="#4c1"
    elif [ "$ANY_FAILED" = true ]; then
      STATUS="failed"; COLOR="#e05d44"
    else
      STATUS="running"; COLOR="#dfb317"
    fi

    mkdir -p assets
    sed -e "s|{{COLOR}}|$COLOR|g" -e "s|{{STATUS}}|$STATUS|g" "$[[ inputs.badge_template ]]" > "$[[ inputs.badge_output ]]"
    CONTENT_BASE64=$(base64 -w 0 "$[[ inputs.badge_output ]]")
    ENCODED_FILE_PATH=$(printf '%s' "$[[ inputs.badge_output ]]" | jq -s -R -r @uri)

    curl --request PUT --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
      --header "Content-Type: application/json" \
      --data "{
        \"branch\": \"$GITLAB_BRANCH\",
        \"content\": \"$CONTENT_BASE64\",
        \"commit_message\": \"Update release badge for $CI_COMMIT_TAG\",
        \"encoding\": \"base64\"
      }" \
      "$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/files/$ENCODED_FILE_PATH"