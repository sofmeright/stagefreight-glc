spec:
  inputs:
    # input_section_name- StageFreight Settings
    # input_section_desc- Core settings used by StageFreight.
    badge_template:
      default: "assets/badge-release-generic.svg"
      description: "SVG template for badge generation"
    badge_output:
      default: "assets/badge-release-status.svg"
      description: "Final badge output path"
    component_spec_file:
      default:
        - "templates/run.yml"
      description: "Array of component spec files (for README input info)"
      type: array
    output_md_file:
      default: "artifacts/component_inputs.md"
      description: "Location to store generated component info Markdown artifact."
    readme_file:
      default: "README.md"
      description: "README file to inject Markdown input map into"
    # input_section_name- GitLab CI/CD Inputs
    # input_section_desc- Inputs that configure GitLab Job behavior
    artifacts:
      default: []
      description: 'An array of paths to preserve as CI/CD artifacts.'
      type: array
    branch_name:
      default: "main"
      description: "Branch to push badge/README changes to"
    gitlab_branch:
      default: 'main'
      description: 'Target Git branch for commits.'
    gitlab_domain:
      default: "https://gitlab.prplanit.com"
      description: "Base GitLab domain (used for badge & catalog links)"
    gitlab_job:
      default: run-ansible
      description: 'The intended name of the CI job spawned by this component.'
    gitlab_stage:
      default: ansible
      description: 'The intended name of the CI stage this job will run in.'
    gitlab_token:
      default: ''
      description: 'Token for authenticating GitLab API calls.'

---

generate_readme_component_inputs:
  artifacts:
    paths:
      - artifacts/
      - assets/
      - scripts/
    expire_in: 1 hour
  stage: release
  image: alpine:3.22.1
  only: [tags]
  variables:
    YQ_VERSION: "v4.44.1"
    YQ_BINARY: "yq_linux_amd64"
  before_script:
    - apk add --no-cache curl jq bash coreutils
    - curl -Ls "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/${YQ_BINARY}" -o /usr/bin/yq
    - chmod +x /usr/bin/yq
  script:
    - mkdir -p artifacts
    - yq '.spec.inputs' "$[[ inputs.component_spec_file ]]" > artifacts/_inputs_raw.yaml
    - sed -i '/^---$/,$d' artifacts/_inputs_raw.yaml
    - chmod +x scripts\gitlab\components\generate-component_inputs_table.sh
    - ./scripts\gitlab\components\generate-component_inputs_table.sh artifacts/_inputs_raw.yaml "$[[ inputs.output_md_file ]]"
    - >
      awk -v start="<!-- START_C_INPUTS_MAP -->" -v end="<!-- END_C_INPUTS_MAP -->" -v content="$(sed 's/\\/\\\\/g; s/"/\\"/g' $[[ inputs.output_md_file ]] | awk '{ print "echo \"" $0 "\"" }')" '
        BEGIN {inblock=0}
        $0 ~ start { print; system(content); inblock=1; next }
        $0 ~ end { inblock=0 }
        !inblock { print }
      ' "$[[ inputs.readme_file ]]" > updated_readme.md
    - CONTENT_BASE64=$(base64 -w 0 updated_readme.md)
    - ENCODED_FILE_PATH=$(printf '%s' "$[[ inputs.readme_file ]]" | jq -s -R -r @uri)
    - >
      curl --request PUT --header "PRIVATE-TOKEN: $GITLAB_TOKEN"
        --header "Content-Type: application/json"
        --data "{
          \"branch\": \"$[[ inputs.branch_name ]]\",
          \"content\": \"$CONTENT_BASE64\",
          \"commit_message\": \"Update component input map for $CI_COMMIT_TAG\",
          \"encoding\": \"base64\"
        }"
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/files/$ENCODED_FILE_PATH"
  artifacts:
    paths: ["$[[ inputs.output_md_file ]]"]

generate_release_notes:
  artifacts:
    paths:
      - artifacts/
      - assets/
      - scripts/
    expire_in: 1 hour
  stage: release
  image: alpine:3.22.1
  only:
    - tags
  before_script:
    - chmod +x ./scripts/gitlab/generate-release_notes.sh
  script:
    - apk add --no-cache bash curl git
    - ./scripts/gitlab/generate-release_notes.sh > release.md
    - test -s release.md || (echo "❌ release.md is empty!" && exit 1)
    - echo "✅ release.md created successfully"

create-release:
  artifacts:
    paths:
      - artifacts/
      - assets/
      - scripts/
    expire_in: 1 hour
  stage: release
  image: alpine:3.22.1
  needs: [generate_release_notes]
  only:
    - tags
  before_script:
    - apk add --no-cache bash curl jq
  script:
    - RELEASE_NOTES=$(cat release.md)
    - >
      curl --fail --silent --header "PRIVATE-TOKEN: $GITLAB_TOKEN" --request POST
      --form "name=Release $CI_COMMIT_TAG"
      --form "tag_name=$CI_COMMIT_TAG"
      --form "description=$RELEASE_NOTES"
      "$CI_API_V4_URL/projects/$CI_PROJECT_ID/releases" || echo "Release might already exist"
    - COMPONENT_NAME="ansible"
    - CATALOG_LINK="$[[ inputs.gitlab_domain ]]/explore/catalog/components/$COMPONENT_NAME"
    - >
      curl --silent --fail --header "PRIVATE-TOKEN: $GITLAB_TOKEN"
      --request POST --header "Content-Type: application/json"
      --data "{\"name\":\"Ansible Component in GitLab Catalog\",\"url\":\"$CATALOG_LINK\",\"link_type\":\"other\"}"
      "$CI_API_V4_URL/projects/$CI_PROJECT_ID/releases/$CI_COMMIT_TAG/assets/links"

update_release_pipeline_status_badge:
  stage: release
  image: alpine:3.22.1
  only: [tags]
  needs: [generate_readme_component_inputs, generate_release_notes, create-release]
  script: |
    apk add --no-cache curl jq bash coreutils
    JOB_STATUSES=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_TOKEN" "$CI_API_V4_URL/projects/$CI_PROJECT_ID/pipelines/$CI_PIPELINE_ID/jobs" | jq -r '.[].status')

    ALL_SUCCESS=true
    ANY_FAILED=false
    for status in $JOB_STATUSES; do
      case "$status" in
        failed) ANY_FAILED=true; ALL_SUCCESS=false;;
        running|pending) ALL_SUCCESS=false;;
      esac
    done

    if [ "$ALL_SUCCESS" = true ]; then
      STATUS="passed"; COLOR="#4c1"
    elif [ "$ANY_FAILED" = true ]; then
      STATUS="failed"; COLOR="#e05d44"
    else
      STATUS="running"; COLOR="#dfb317"
    fi

    mkdir -p assets
    sed -e "s|{{COLOR}}|$COLOR|g" -e "s|{{STATUS}}|$STATUS|g" "$[[ inputs.badge_template ]]" > "$[[ inputs.badge_output ]]"
    CONTENT_BASE64=$(base64 -w 0 "$[[ inputs.badge_output ]]")
    ENCODED_FILE_PATH=$(printf '%s' "$[[ inputs.badge_output ]]" | jq -s -R -r @uri)

    curl --request PUT --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
      --header "Content-Type: application/json" \
      --data "{
        \"branch\": \"$[[ inputs.branch_name ]]\",
        \"content\": \"$CONTENT_BASE64\",
        \"commit_message\": \"Update release badge for $CI_COMMIT_TAG\",
        \"encoding\": \"base64\"
      }" \
      "$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/files/$ENCODED_FILE_PATH"
  artifacts:
    paths: ["$[[ inputs.badge_output ]]"]
    expire_in: 1 hour